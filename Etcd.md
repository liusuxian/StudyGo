### Leader选举
- Leader选举常常用在主从架构的系统中。主从架构中的服务节点分为主（Leader、Master）和从（Follower、Slave）两种角色，实际节点包括1主n从，一共是n+1个节点。
- 主节点常常执行写操作，从节点常常执行读操作，如果读写都在主节点，从节点只是提供一个备份功能的话，那么主从架构就会退化成主备模式架构。
- 在同一时刻，系统中不能有两个主节点，否则，如果两个节点都是主，都执行写操作的话，就有可能出现数据不一致的情况，所以，我们需要一个选主机制，选择一个节点作为主节点，这个过程就是Leader选举。
- 当主节点宕机或者是不可用时，就需要新一轮的选举，从其它的从节点中选择出一个节点，让它作为新主节点，宕机的原主节点恢复后，可以变为从节点，或者被摘掉。
### 选举
- 如果你的业务集群还没有主节点，或者主节点宕机了，你就需要发起新一轮的选主操作，主要会用到Campaign和Proclaim。如果你需要主节点放弃主的角色，让其它从节点有机会成为主节点，就可以调用Resign方法。
- 第一个方法是Campaign。它的作用是，把一个节点选举为主节点，并且会设置一个值。它的签名如下所示：
``` go
func (e *Election) Campaign(ctx context.Context, val string) error
```
  - 需要注意的是，这是一个阻塞方法，在调用它的时候会被阻塞，直到满足下面的三个条件之一，才会取消阻塞。
    - 成功当选为主；
    - 此方法返回错误；
    - ctx被取消。
- 第二个方法是Proclaim。它的作用是，重新设置Leader的值，但是不会重新选主，这个方法会返回新值设置成功或者失败的信息。方法签名如下所示：
``` go
func (e *Election) Proclaim(ctx context.Context, val string) error
```
- 第三个方法是 Resign：开始新一次选举。这个方法会返回新的选举成功或者失败的信息。它的签名如下所示：
``` go
func (e *Election) Resign(ctx context.Context) (err error)
```
### 查询
- etcd提供了查询当前Leader的方法Leader，如果当前还没有Leader，就返回一个错误，你可以使用这个方法来查询主节点信息。这个方法的签名如下：
``` go
func (e *Election) Leader(ctx context.Context) (*v3.GetResponse, error)
```
- 每次主节点的变动都会生成一个新的版本号，你还可以查询版本号信息（Rev方法），了解主节点变动情况：
``` go
func (e *Election) Rev() int64
```
### 监控
- 我们可以通过Observe来监控主的变化，它的签名如下：
``` go
func (e *Election) Observe(ctx context.Context) <-chan v3.GetResponse
```
- 它会返回一个chan，显示主节点的变动信息。需要注意的是，它不会返回主节点的全部历史变动信息，而是只返回最近的一条变动信息以及之后的变动信息。
### 互斥锁
- 互斥锁的应用场景和主从架构的应用场景不太一样。使用互斥锁的不同节点是没有主从这样的角色的，所有的节点都是一样的，只不过在同一时刻，只允许其中的一个节点持有锁。